2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Current SDK version is 0.17.0
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Configure stats pid to 2631
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Loading settings from /Users/sultandaniels/.config/wandb/settings
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Loading settings from /Users/sultandaniels/Documents/Transformer_Kalman/mop_modifications/wandb/settings
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Loading settings from environment variables: {}
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Inferring run settings from compute environment: {'program_relpath': 'streamlined_mop/src/data_train.py', 'program_abspath': '/Users/sultandaniels/Documents/Transformer_Kalman/mop_modifications/streamlined_mop/src/data_train.py', 'program': '/Users/sultandaniels/Documents/Transformer_Kalman/mop_modifications/streamlined_mop/src/data_train.py'}
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Applying login settings: {}
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_setup.py:_flush():76] Applying login settings: {}
2024-06-07 17:18:04,706 INFO    MainThread:2631 [wandb_init.py:_log_setup():520] Logging user logs to /Users/sultandaniels/Documents/Transformer_Kalman/mop_modifications/wandb/run-20240607_171804-ab25h6nx/logs/debug.log
2024-06-07 17:18:04,707 INFO    MainThread:2631 [wandb_init.py:_log_setup():521] Logging internal logs to /Users/sultandaniels/Documents/Transformer_Kalman/mop_modifications/wandb/run-20240607_171804-ab25h6nx/logs/debug-internal.log
2024-06-07 17:18:04,707 INFO    MainThread:2631 [wandb_init.py:init():560] calling init triggers
2024-06-07 17:18:04,707 INFO    MainThread:2631 [wandb_init.py:init():567] wandb.init called with sweep_config: {}
config: {'ckpt_path': '', 'seed': 0, 'fully_reproducible': False, 'num_tasks': 40, 'num_val_tasks': 3, 'dataset_typ': 'unifA', 'C_dist': '_unif_C', 'nx': 10, 'ny': 5, 'n_noise': 1, 'num_traces': {'train': 1, 'val': 2000}, 'train_steps': 7, 'batch_size': 28, 'train_data_workers': 1, 'test_batch_size': 2, 'test_data_workers': 1, 'num_epochs': 1, 'n_positions': 250, 'n_embd': 128, 'n_layer': 12, 'n_head': 8, 'n_dims_in': 5, 'n_dims_out': 5, 'changing': False, 'learning_rate': 0.0003, 'weight_decay': 0.01, 'gradient_clip_algorithm': 'norm', 'gradient_clip_val': 1.0, '_Config__get_config_file_contents': <classmethod(<function Config.__get_config_file_contents at 0x16ed1b2e0>)>, '_Config__filecontents': {'config.py': 'import yaml\nimport os\nimport zipfile\nimport argparse\n\nimport coloredlogs\nfrom utils import log_info\nfrom utils import Singleton\nfrom utils import set_seed\n\n\n# /checkpoints/step=10000.ckpt\n\nclass Config(object, metaclass=Singleton):\n    ckpt_path = ""\n    # ckpt_path = "/Users/sultandaniels/Documents/Transformer_Kalman/outputs/GPT2/240529_111352.3b8b85_unifA_unif_C/checkpoints/step=7.ckpt"\n    # ckpt_path = "../outputs/GPT2/240425_225022.52199c/checkpoints/batch_size_28_con_len_250_step=20000.ckpt" #20000 steps gaussA gaussC\n    # ckpt_path = "../outputs/GPT2/240320_014524.c78f58/checkpoints/num_tasks_28_con_len_250_step=20000.ckpt" #checkpoint of dense A uniform C\n    seed = 0\n    fully_reproducible = False\n\n    # Dataset settings\n    num_tasks = 40 #40000 #number of training systems\n    num_val_tasks = 3 #number of test systems\n    dataset_typ = "unifA" #"gaussA" #"rotDiagA" #"upperTriA" #"ypred"\n    C_dist = "_unif_C" #"_unif_C" #"_gauss_C" #"_gauss_C_large_var"\n    nx = 10\n    ny = 5\n    n_noise = 1\n    num_traces = {"train": 1, "val": 2000}\n\n    # Training settings\n    train_steps = 7\n    batch_size = 28 #does changing this by 2x or 0.5x change the training time? (if no effect than batch size is too big)\n    train_data_workers = 1 #set to 1 (check if it changes the speed of the training process)\n    test_batch_size = 2 #256\n    test_data_workers = 1 #4 #set to 1\n    num_epochs = 1\n\n    # Model settings\n    n_positions = 250 #500 for extended OLS #250 #context length\n    n_embd = 128\n    n_layer = 12\n    n_head = 8\n    n_dims_in = 5\n    n_dims_out = 5  #(IMPORTANT TO KEEP THIS AT 5 FOR NOW) TODO: this used to be 10 but needs to be fixed to match lin_sys.yaml\n    changing = False  # only used for plotting\n\n    # Optimizer parameters\n    learning_rate = 3e-4\n    weight_decay = 1e-2\n\n    # Gradient Clipping\n    gradient_clip_algorithm = \'norm\'  # \'norm\' or \'value\'\n    gradient_clip_val = 1.0\n\n    def __new__(cls):\n        __instance = super().__new__(cls)\n        cls.__filecontents = cls.__get_config_file_contents()\n        cls.__immutable = True\n        return __instance\n\n    def import_yaml(self, yaml_path, strict=True):\n        """Import YAML config to over-write existing config entries."""\n        assert os.path.isfile(yaml_path)\n        assert not hasattr(self.__class__, \'__imported_yaml_path\')\n        log_info(\'Loading \' + yaml_path)\n        with open(yaml_path, \'r\') as f:\n            yaml_string = f.read()\n        self.import_dict(\n            yaml.load(yaml_string, Loader=yaml.FullLoader), strict=strict)\n        self.__class__.__imported_yaml_path = yaml_path\n        self.__class__.__filecontents[os.path.basename(\n            yaml_path)] = yaml_string\n\n    def override(self, key, value):\n        self.__class__.__immutable = False\n        if not hasattr(self, key):\n            raise Exception("Tried to override non-existing key: " + key)\n        setattr(self, key, value)\n        self.__class__.__immutable = True\n\n    def import_dict(self, dictionary, strict=True):\n        """Import a set of key-value pairs from a dict to over-write existing config entries."""\n        self.__class__.__immutable = False\n        for key, value in dictionary.items():\n            if strict is True:\n                if not hasattr(self, key):\n                    raise ValueError(\'Unknown configuration key: \' + key)\n                if type(getattr(self, key)) is float and type(value) is int:\n                    value = float(value)\n                else:\n                    assert type(getattr(self, key)) is type(\n                        value), f"{key}, {type(getattr(self, key))}, {type(value)}"\n                if not isinstance(getattr(self, key), property):\n                    setattr(self, key, value)\n            else:\n                if hasattr(Config, key):\n                    if not isinstance(getattr(self, key), property):\n                        setattr(self, key, value)\n                else:\n                    setattr(self, key, value)\n        self.__class__.__immutable = True\n\n    @classmethod\n    def __get_config_file_contents(cls):\n        """Retrieve and cache default and user config file contents."""\n        out = {}\n        for relpath in [\'config.py\']:\n            path = os.path.relpath(os.path.dirname(__file__) + \'/\' + relpath)\n            assert os.path.isfile(path)\n            with open(path, \'r\') as f:\n                out[os.path.basename(path)] = f.read()\n        return out\n\n    def get_all_key_values(self):\n        return dict([\n            (key, getattr(self, key))\n            for key in dir(self)\n            if not key.startswith(\'_Config\')\n               and not key.startswith(\'__\')\n               and not callable(getattr(self, key))\n        ])\n\n    def get_full_yaml(self):\n        return yaml.dump(self.get_all_key_values())\n\n    def write_file_contents(self, target_base_dir):\n        """Write cached config file contents to target directory."""\n        assert os.path.isdir(target_base_dir)\n\n        # Write config file contents\n        target_dir = target_base_dir + \'/configs\'\n        if not os.path.isdir(target_dir):\n            os.makedirs(target_dir)\n        outputs = {  # Also output flattened config\n            \'combined.yaml\': self.get_full_yaml(),\n        }\n        outputs.update(self.__class__.__filecontents)\n        for fname, content in outputs.items():\n            fpath = os.path.relpath(target_dir + \'/\' + fname)\n            with open(fpath, \'w\') as f:\n                f.write(content)\n                log_info(\'Written %s\' % fpath)\n\n        # Copy source folder contents over\n        target_path = os.path.relpath(target_base_dir + \'/src.zip\')\n        source_path = os.path.relpath(os.path.dirname(__file__) + \'/../\')\n\n        def filter_(x):\n            return x.endswith(\'.py\') or x.endswith(\'.yaml\')  # noqa\n\n        with zipfile.ZipFile(target_path, \'w\', zipfile.ZIP_DEFLATED) as zip_file:\n            for root, dirs, files in os.walk(source_path):\n                for file_or_dir in files + dirs:\n                    full_path = os.path.join(root, file_or_dir)\n                    if os.path.isfile(full_path) and filter_(full_path):\n                        zip_file.write(\n                            os.path.join(root, file_or_dir),\n                            os.path.relpath(os.path.join(root, file_or_dir),\n                                            os.path.join(source_path, os.path.pardir)))\n        log_info(\'Written source folder to %s\' % os.path.relpath(target_path))\n\n    def __setattr__(self, name, value):\n        """Initial configs should not be overwritten!"""\n        if self.__class__.__immutable:\n            raise AttributeError(\'Config instance attributes are immutable.\')\n        else:\n            super().__setattr__(name, value)\n\n    def __delattr__(self, name):\n        """Initial configs should not be removed!"""\n        if self.__class__.__immutable:\n            raise AttributeError(\'Config instance attributes are immutable.\')\n        else:\n            super().__delattr__(name)\n\n    def __eq__(self, other):\n        if isinstance(other, Config):\n            other = other.get_all_key_values()\n        elif type(other) != dict:\n            raise Exception(\'Config can only be compared to Config or dict\')\n        return self.get_all_key_values() == other\n\n    def __convert_cli_arg_type(self, key, value):\n        config_type = type(getattr(self, key))\n        if config_type == bool:\n            if value.lower() in (\'true\', \'yes\', \'y\') or value == \'1\':\n                return True\n            elif value.lower() in (\'false\', \'no\', \'n\') or value == \'0\':\n                return False\n            else:\n                raise ValueError(\n                    \'Invalid input for bool config "%s": %s\' % (key, value))\n        else:\n            return config_type(value)\n\n    def parse_args(self):\n        parser = argparse.ArgumentParser()\n        parser.add_argument(\'-v\', type=str, help=\'Desired logging level.\', default=\'info\',\n                            choices=[\'debug\', \'info\', \'warning\', \'error\', \'critical\'])\n        parser.add_argument(\'config_yaml\', type=str, nargs=\'*\',\n                            help=(\'Path to config in YAML format. \'\n                                  \'Multiple configs will be parsed in the specified order.\'))\n        for key in dir(self):\n            if key.startswith(\'_DefaultConfig\') or key.startswith(\'__\'):\n                continue\n            if key in vars(type(self)) and isinstance(vars(type(self))[key], property):\n                continue\n            value = getattr(self, key)\n            value_type = type(value)\n            arg_type = value_type\n            if value_type == bool:\n                # Handle booleans separately, otherwise arbitrary values become `True`\n                arg_type = str\n            if callable(value):\n                continue\n            parser.add_argument(\'--\' + key.replace(\'_\', \'-\'), type=arg_type, metavar=value,\n                                help=\'Expected type is `%s`.\' % value_type.__name__)\n        args = parser.parse_args()\n\n        # Set logger format and verbosity level\n        coloredlogs.install(\n            datefmt=\'%d/%m %H:%M:%S\',\n            fmt=\'%(asctime)s %(levelname)s %(message)s\',\n            level=args.v.upper(),\n        )\n\n        # Parse configs in order specified by user\n        for yaml_path in args.config_yaml:\n            self.import_yaml(yaml_path)\n\n        # Apply configs passed through command line\n        self.import_dict({\n            key.replace(\'-\', \'_\'): self.__convert_cli_arg_type(key, value)\n            for key, value in vars(args).items()\n            if value is not None and hasattr(self, key)\n        })\n        set_seed(self.seed, self.fully_reproducible)'}, '_Config__immutable': True}
2024-06-07 17:18:04,707 INFO    MainThread:2631 [wandb_init.py:init():610] starting backend
2024-06-07 17:18:04,707 INFO    MainThread:2631 [wandb_init.py:init():614] setting up manager
2024-06-07 17:18:04,707 INFO    MainThread:2631 [backend.py:_multiprocessing_setup():105] multiprocessing start_methods=spawn,fork,forkserver, using: spawn
2024-06-07 17:18:04,709 INFO    MainThread:2631 [wandb_init.py:init():622] backend started and connected
2024-06-07 17:18:04,712 INFO    MainThread:2631 [wandb_init.py:init():711] updated telemetry
2024-06-07 17:18:04,732 INFO    MainThread:2631 [wandb_init.py:init():744] communicating run to backend with 90.0 second timeout
2024-06-07 17:18:04,732 ERROR   MainThread:2631 [wandb_init.py:init():1174] error in wandb.init()
Traceback (most recent call last):
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/sdk/wandb_init.py", line 1164, in init
    return wi.init()
           ^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/sdk/wandb_init.py", line 746, in init
    run_init_handle = backend.interface.deliver_run(run)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/sdk/interface/interface.py", line 809, in deliver_run
    run_record = self._make_run(run)
                 ^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/sdk/interface/interface.py", line 151, in _make_run
    self._make_config(data=config_dict, obj=proto_run.config)
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/sdk/interface/interface.py", line 133, in _make_config
    update.value_json = json_dumps_safer(json_friendly(v)[0])
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/util.py", line 828, in json_dumps_safer
    return dumps(obj, cls=WandBJSONEncoder, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/json/__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/json/encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/json/encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/site-packages/wandb/util.py", line 779, in default
    return json.JSONEncoder.default(self, obj)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/sultandaniels/anaconda3/envs/mop/lib/python3.12/json/encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type classmethod is not JSON serializable
2024-06-07 17:18:05,892 WARNING MsgRouterThr:2631 [router.py:message_loop():77] message_loop has been closed
